/*
var justString string

func someFunc() {
  v := createHugeString(1 &lt;&lt; 10)
  justString = v[:100]
}

func main() {
  someFunc()
}
*/
//данный код имеет следующие недочёты:
//-происходит утечка памяти, из-за генерации избыточного размера строки,
//	если используется только 100 байтов из сгенерированной строки, остальные висят в памяти,
//	из-за механики языка GO срезы ссылаются на массив, а в коде используется только первые 100 байтов из массива
//-избыточная переменная v как и функция someFunc(), можно явно указать в функции main() генерацию строки
//	и сразу присвоить переменной justString
//-при обрезке строки, при использовании разных кодировках может пострадать валидность последних символов,
//	хранящихся в переменной justString
//-использование глобальной переменной justString, т.к. доступ к ней имеется из любого места кода
//
//что происходит с переменной justString:
//-нет проверки на валидность символов, может хранить не валидную строку
//-доступ к переменной из любого места программы
//-время жизни переменной в течении работы все программы, сборщик мусора не сможет очистить если переменная станет не нужна
//	область видимости, вся программа
//
//я бы изменил код так:
//func main() {
//	justString := createHugeString(100)
//}
//-убрал ненужную функцию и создание промежуточной переменной
//-ограничил область видимости переменной justString, создав в функции main()
//-генерирую строку размером 100 байт, т.к. только этот размер планируется использовать
//-не провожу проверку на валидацию строки, т.к. по логике она должна быть в функции createHugeString()
//
//по итогу:
//-код более компактный,
//-легче читается,
//-легче отслеживание переменной justString,
//-нет утечки памяти